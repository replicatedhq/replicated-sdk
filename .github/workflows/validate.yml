name: PR/main branch CI

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  APP_SLUG: replicated-sdk-e2e

jobs:
  test-unit:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Run unit tests
        run: make test-unit

  test-pact:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v6

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install Ruby and Pact dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev build-essential
          sudo gem install pact-mock_service -v '>=3.5.0'
          sudo gem install pact-provider-verifier -v '>=1.36.1' --force
          sudo gem install pact_broker-client -v '>=1.22.3'

      - name: Install pact-cli binaries
        run: |
          mkdir -p /tmp/pact-bin
          docker create --name pact-cli pactfoundation/pact-cli:latest
          docker cp pact-cli:/usr/bin/pact /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pact-mock-service /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pact-stub-service /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pact-broker /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pact-provider-verifier /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pactflow /tmp/pact-bin/
          docker cp pact-cli:/usr/bin/pact-message /tmp/pact-bin/
          docker rm pact-cli
          sudo cp /tmp/pact-bin/* /usr/local/bin/
          sudo chmod +x /usr/local/bin/pact*
          sudo ln -sf /usr/local/bin/pact-broker /usr/local/bin/pact-broker-client

      - name: Get Pact token from 1Password
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          PACT_BROKER_TOKEN: op://Developer Automation/Pactflow read-only token/credential

      - name: Run pact tests
        env:
          PACT_VERSION: ${{ github.sha }}
          PACT_BROKER_BASE_URL: https://replicated.pactflow.io
        run: make test-pact

  build-image:
    runs-on: ubuntu-22.04
    outputs:
      image-registry: ${{ steps.build.outputs.registry }}
      image-repository: ${{ steps.build.outputs.repository }}
      image-tag: ${{ steps.build.outputs.tag }}
      image-ref: ${{ steps.build.outputs.ref }}
    steps:
      - uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push SDK image
        id: build
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          REGISTRY="ttl.sh"
          REPOSITORY="automated-${TIMESTAMP}/replicated-image/replicated-sdk"
          TAG="24h"
          IMAGE_REF="${REGISTRY}/${REPOSITORY}:${TAG}"

          docker buildx build \
            --platform linux/amd64 \
            -f deploy/Dockerfile \
            -t "${IMAGE_REF}" \
            --push \
            .

          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repository=${REPOSITORY}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "ref=${IMAGE_REF}" >> $GITHUB_OUTPUT
          echo "Image pushed to ${IMAGE_REF}"

  build-chart:
    runs-on: ubuntu-22.04
    needs: build-image
    outputs:
      chart-ref: ${{ steps.build.outputs.ref }}
    steps:
      - uses: actions/checkout@v6

      - name: Build and push SDK chart
        id: build
        env:
          IMAGE_REGISTRY: ${{ needs.build-image.outputs.image-registry }}
          IMAGE_REPOSITORY: ${{ needs.build-image.outputs.image-repository }}
          IMAGE_TAG: ${{ needs.build-image.outputs.image-tag }}
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          CHART_REF="oci://ttl.sh/automated-${TIMESTAMP}/replicated-chart"

          # Update values.yaml with the built image
          cd chart
          sed -i "s|registry: proxy.replicated.com|registry: ${IMAGE_REGISTRY}|" values.yaml
          sed -i "s|repository: \"library/replicated-sdk-image\"|repository: \"${IMAGE_REPOSITORY}\"|" values.yaml
          sed -i "s|tag: \"1.0.0\"|tag: \"${IMAGE_TAG}\"|" values.yaml

          # Package and push chart
          helm package .
          helm push replicated-1.0.0.tgz "${CHART_REF}"

          echo "ref=${CHART_REF}" >> $GITHUB_OUTPUT
          echo "Chart pushed to ${CHART_REF}"

  create-release:
    runs-on: ubuntu-22.04
    needs: build-chart
    outputs:
      channel-slug: ${{ steps.release.outputs.channel }}
    steps:
      - uses: actions/checkout@v6

      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
            | grep "browser_download_url.*linux_amd64.tar.gz" \
            | cut -d : -f 2,3 \
            | tr -d \" \
            | wget -qi -
          tar xf replicated_*_linux_amd64.tar.gz replicated
          sudo mv replicated /usr/local/bin/replicated
          sudo chmod +x /usr/local/bin/replicated
          rm replicated_*_linux_amd64.tar.gz

      - name: Create wrapped test chart
        env:
          CHART_REF: ${{ needs.build-chart.outputs.chart-ref }}
        run: |
          cd test-chart
          cat >> Chart.yaml << EOF
          dependencies:
          - name: replicated
            version: 1.0.0
            repository: ${CHART_REF}
          EOF

          helm dep update
          helm package .
          mv test-chart-0.1.0.tgz /tmp/

      - name: Get Replicated token from 1Password
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          REPLICATED_API_TOKEN: op://Developer Automation/Replicated/service_account

      - name: Create channel and release
        id: release
        run: |
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          CHANNEL_NAME="automated-${TIMESTAMP}"

          # Create KOTS application files
          cat > /tmp/app.yaml << 'EOF'
          apiVersion: kots.io/v1beta1
          kind: Application
          metadata:
            name: replicated-sdk-e2e
          spec:
            title: Replicated SDK E2E
            icon: https://raw.githubusercontent.com/cncf/artwork/master/projects/kubernetes/icon/color/kubernetes-icon-color.png
          EOF

          cat > /tmp/config.yaml << 'EOF'
          apiVersion: kots.io/v1beta1
          kind: Config
          metadata:
            name: my-application
          spec:
            groups:
              - name: replicated_sdk_e2e
                title: Replicated SDK E2E
                description: Configuration for the Replicated SDK E2E
                items:
                  - name: test_item
                    type: bool
                    default: "0"
          EOF

          cat > /tmp/helm.yaml << 'EOF'
          apiVersion: kots.io/v1beta2
          kind: HelmChart
          metadata:
            name: replicated-sdk-e2e
          spec:
            # chart identifies a matching chart from a .tgz
            chart:
              name: test-chart
              chartVersion: 0.1.0

            # values are used in the customer environment, as a pre-render step
            # these values will be supplied to helm template
            values: {}

            # builder values provide a way to render the chart with all images
            # and manifests. this is used in replicated to create air gap packages
            builder: {}
          EOF

          # Create channel
          replicated channel create \
            --app ${APP_SLUG} \
            --name "${CHANNEL_NAME}"

          # Create release
          replicated release create \
            --app ${APP_SLUG} \
            --version 0.1.0 \
            --promote "${CHANNEL_NAME}" \
            --yaml-dir /tmp

          echo "channel=${CHANNEL_NAME}" >> $GITHUB_OUTPUT
          echo "Created channel: ${CHANNEL_NAME}"

  create-customer:
    runs-on: ubuntu-22.04
    needs: create-release
    outputs:
      customer-id: ${{ steps.customer.outputs.id }}
      license-id: ${{ steps.customer.outputs.license }}
      app-id: ${{ steps.app.outputs.id }}
    steps:
      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
            | grep "browser_download_url.*linux_amd64.tar.gz" \
            | cut -d : -f 2,3 \
            | tr -d \" \
            | wget -qi -
          tar xf replicated_*_linux_amd64.tar.gz replicated
          sudo mv replicated /usr/local/bin/replicated
          sudo chmod +x /usr/local/bin/replicated
          rm replicated_*_linux_amd64.tar.gz

      - name: Get Replicated token from 1Password
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          REPLICATED_API_TOKEN: op://Developer Automation/Replicated/service_account

      - name: Get app ID
        id: app
        run: |
          APP_LIST=$(replicated app ls)

          APP_ID=$(echo "${APP_LIST}" | awk -v slug="${APP_SLUG}" '
            $0 !~ /^ID/ && $0 !~ /^--/ && NF >= 3 {
              for (i=1; i<=NF; i++) {
                if ($(i) == slug) {
                  print $1;
                  exit;
                }
              }
            }
          ')

          echo "id=${APP_ID}" >> $GITHUB_OUTPUT
          echo "App ID: ${APP_ID}"

      - name: Create customer
        id: customer
        env:
          CHANNEL_SLUG: ${{ needs.create-release.outputs.channel-slug }}
        run: |
          CUSTOMER_JSON=$(replicated customer create \
            --app ${APP_SLUG} \
            --kots-install=false \
            --name test-customer \
            --channel "${CHANNEL_SLUG}" \
            --email test-customer@replicated.com \
            --output json)

          CUSTOMER_ID=$(echo "${CUSTOMER_JSON}" | jq -r '.id')
          LICENSE_ID=$(echo "${CUSTOMER_JSON}" | jq -r '.installationId')

          echo "id=${CUSTOMER_ID}" >> $GITHUB_OUTPUT
          echo "license=${LICENSE_ID}" >> $GITHUB_OUTPUT
          echo "Customer ID: ${CUSTOMER_ID}"
          echo "License ID: ${LICENSE_ID}"

  get-distributions:
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.distributions.outputs.matrix }}
    steps:
      - name: Install Replicated CLI
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
            | grep "browser_download_url.*linux_amd64.tar.gz" \
            | cut -d : -f 2,3 \
            | tr -d \" \
            | wget -qi -
          tar xf replicated_*_linux_amd64.tar.gz replicated
          sudo mv replicated /usr/local/bin/replicated
          sudo chmod +x /usr/local/bin/replicated
          rm replicated_*_linux_amd64.tar.gz

      - name: Get Replicated token from 1Password
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          REPLICATED_API_TOKEN: op://Developer Automation/Replicated/service_account

      - name: Get CMX distributions
        id: distributions
        run: |
          VERSIONS_JSON=$(replicated cluster versions --output json)

          # Extract distributions and their latest versions
          MATRIX=$(echo "${VERSIONS_JSON}" | jq -c '[
            .[] |
            select(.short_name == "gke" or .short_name == "eks" or .short_name == "openshift" or .short_name == "oke") |
            {
              distribution: .short_name,
              version: .versions[-1]
            }
          ]')

          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
          echo "Distribution matrix: ${MATRIX}"

  integration-test:
    runs-on: ubuntu-22.04
    needs: [test-unit, test-pact, build-image, create-release, create-customer, get-distributions]
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.get-distributions.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v6

      - name: Get Replicated token from 1Password
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          REPLICATED_API_TOKEN: op://Developer Automation/Replicated/service_account

      - name: Create cluster
        id: cluster
        uses: replicatedhq/replicated-actions/create-cluster@v1
        with:
          api-token: ${{ env.REPLICATED_API_TOKEN }}
          kubernetes-distribution: ${{ matrix.distribution }}
          kubernetes-version: ${{ matrix.version }}
          ttl: 15m
          timeout-minutes: 15

      - name: Save kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ steps.cluster.outputs.cluster-kubeconfig }}" > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Patch EKS storage class (if needed)
        if: matrix.distribution == 'eks'
        run: |
          kubectl patch storageclass gp2 -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

      - name: Install test chart
        env:
          LICENSE_ID: ${{ needs.create-customer.outputs.license-id }}
          CHANNEL_SLUG: ${{ needs.create-release.outputs.channel-slug }}
        run: |
          helm registry login registry.replicated.com \
            --username test-customer@replicated.com \
            --password "${LICENSE_ID}"

          helm install test-chart \
            "oci://registry.replicated.com/${APP_SLUG}/${CHANNEL_SLUG}/test-chart" \
            --version 0.1.0 \
            --wait \
            --timeout 5m

      - name: Wait for replicated deployment
        run: |
          kubectl wait --for=condition=available deployment/replicated --timeout=2m || true
          kubectl get pods

      - name: Run e2e tests
        env:
          APP_ID: ${{ needs.create-customer.outputs.app-id }}
          CUSTOMER_ID: ${{ needs.create-customer.outputs.customer-id }}
          LICENSE_ID: ${{ needs.create-customer.outputs.license-id }}
          CHANNEL_SLUG: ${{ needs.create-release.outputs.channel-slug }}
          SDK_IMAGE: ${{ needs.build-image.outputs.image-ref }}
        run: |
          # Create TLS certificate
          openssl req -x509 -newkey rsa:4096 \
            -keyout /tmp/test-key.key \
            -out /tmp/test-cert.crt \
            -days 365 -nodes \
            -subj "/CN=test.com"

          # Create TLS secret
          kubectl create secret tls test-tls \
            --cert=/tmp/test-cert.crt \
            --key=/tmp/test-key.key

          # Upgrade chart with TLS enabled
          helm registry login registry.replicated.com \
            --username test-customer@replicated.com \
            --password "${LICENSE_ID}"

          helm upgrade test-chart \
            "oci://registry.replicated.com/${APP_SLUG}/${CHANNEL_SLUG}/test-chart" \
            --version 0.1.0 \
            --set replicated.tlsCertSecretName=test-tls \
            --wait \
            --timeout 5m

          kubectl rollout restart deploy/replicated
          kubectl rollout status deploy/replicated --timeout=2m

          # Deploy SSL test pod
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: replicated-ssl-test
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: replicated-ssl-test
            template:
              metadata:
                labels:
                  app: replicated-ssl-test
              spec:
                containers:
                - name: replicated-ssl-test
                  image: docker.io/alpine/curl:latest
                  command: ["sleep", "500d"]
                  ports:
                  - containerPort: 3000
                  readinessProbe:
                    exec:
                      command: ["curl", "-k", "https://replicated:3000/health"]
                    initialDelaySeconds: 10
                    periodSeconds: 10
          EOF

          kubectl wait --for=condition=available deployment/replicated-ssl-test --timeout=2m

          echo "✅ TLS test passed for ${{ matrix.distribution }} ${{ matrix.version }}"

      - name: Test minimal RBAC
        env:
          LICENSE_ID: ${{ needs.create-customer.outputs.license-id }}
          CHANNEL_SLUG: ${{ needs.create-release.outputs.channel-slug }}
        run: |
          # Upgrade with minimal RBAC
          helm registry login registry.replicated.com \
            --username test-customer@replicated.com \
            --password "${LICENSE_ID}"

          helm upgrade test-chart \
            "oci://registry.replicated.com/${APP_SLUG}/${CHANNEL_SLUG}/test-chart" \
            --version 0.1.0 \
            --set replicated.tlsCertSecretName=test-tls \
            --set replicated.minimalRBAC=true \
            --set-json 'replicated.statusInformers=["deployment/test-chart","service/test-chart","daemonset/test-daemonset","statefulset/test-statefulset","pvc/test-pvc"]' \
            --wait \
            --timeout 5m

          kubectl rollout restart deploy/replicated
          kubectl rollout restart deploy/test-chart
          kubectl rollout status deploy/replicated --timeout=2m

          # Verify RBAC role
          kubectl describe role replicated-role

          echo "✅ Minimal RBAC test passed for ${{ matrix.distribution }} ${{ matrix.version }}"

      - name: Get replicated logs
        if: always()
        run: |
          echo "=== Replicated SDK logs ==="
          kubectl logs deployment/replicated --tail=100 || true

          echo "=== All pods ==="
          kubectl get pods -o wide || true

      - name: Remove cluster
        if: always()
        uses: replicatedhq/replicated-actions/remove-cluster@v1
        with:
          api-token: ${{ env.REPLICATED_API_TOKEN }}
          cluster-id: ${{ steps.cluster.outputs.cluster-id }}

  cleanup:
    runs-on: ubuntu-22.04
    if: always()
    needs: [create-release, create-customer, integration-test]
    steps:
      - name: Install Replicated CLI
        if: needs.create-customer.outputs.customer-id || needs.create-release.outputs.channel-slug
        run: |
          curl -s https://api.github.com/repos/replicatedhq/replicated/releases/latest \
            | grep "browser_download_url.*linux_amd64.tar.gz" \
            | cut -d : -f 2,3 \
            | tr -d \" \
            | wget -qi -
          tar xf replicated_*_linux_amd64.tar.gz replicated
          sudo mv replicated /usr/local/bin/replicated
          sudo chmod +x /usr/local/bin/replicated
          rm replicated_*_linux_amd64.tar.gz

      - name: Get Replicated token from 1Password
        if: needs.create-customer.outputs.customer-id || needs.create-release.outputs.channel-slug
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT }}
          REPLICATED_API_TOKEN: op://Developer Automation/Replicated/service_account

      - name: Archive customer
        if: needs.create-customer.outputs.customer-id
        env:
          CUSTOMER_ID: ${{ needs.create-customer.outputs.customer-id }}
        run: |
          replicated customer archive --customer "${CUSTOMER_ID}" || true

      - name: Archive channel
        if: needs.create-release.outputs.channel-slug
        env:
          CHANNEL_SLUG: ${{ needs.create-release.outputs.channel-slug }}
        run: |
          replicated channel rm --channel "${CHANNEL_SLUG}" --app ${APP_SLUG} || true
